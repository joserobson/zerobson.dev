---
title: 'Tackling Primitive Obsession in C#'
date: "2025-09-26"
description: 'Understanding and fixing the Primitive Obsession code smell in C# with value objects.'
tags: ["C#", "Code Smell", "Primitive Obsession", "Value Objects"]
---

# Tackling Primitive Obsession in C#

Primitive Obsession is a code smell where we excessively use primitive data types (like `string`, `int`, `decimal`) to represent meaningful concepts in our domain. Instead of creating specific, small classes for things like a phone number, an email address, or a monetary value, we just pass around simple strings and numbers.

While this might seem quick and easy initially, it often leads to fragile, less expressive, and harder-to-maintain code.

## The Problem: A Simple Example

Imagine we have `Customer` and `Order` classes in an e-commerce application. A first-pass implementation suffering from primitive obsession might look like this:

```csharp
public class Customer
{
    public Guid Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    // What makes this a valid email?
    public string Email { get; set; }
}

public class Order
{
    public Guid Id { get; set; }
    public Guid CustomerId { get; set; }
    // Is this price in USD, EUR, or something else?
    public decimal TotalPrice { get; set; }
    // How do we ensure this is a valid ISO currency code?
    public string Currency { get; set; }
}
```

## Why Is This a Problem?

This approach has several significant downsides:

*   **Implicit Knowledge:** The code doesn't explicitly state the rules. What constitutes a valid email? What format should the currency string be in? This knowledge is scattered across the codebase in various validation methods, or worse, just exists in the developers' heads.
*   **No Centralized Validation:** If you need to validate an email, you have to repeat the validation logic everywhere you accept an email string. If the validation rules change, you have to find and update every single occurrence.
*   **Lack of Type Safety:** Any string can be passed into the `Email` property, and any decimal can be assigned to `TotalPrice`. The compiler can't help you prevent invalid data from entering your system.
*   **Reduced Readability:** A method signature like `ProcessPayment(decimal amount, string currency)` is less clear than `ProcessPayment(Money amount)`. The second signature immediately tells you that the two parameters are related and represent a single concept.

## The Solution: Embracing Value Objects

The solution is to create small, immutable **Value Objects** that encapsulate the logic and validation for each domain concept. In modern C#, `record` types are perfect for this.

Let's create value objects for `Email` and `Money`.

```csharp
public record Email
{
    public string Value { get; }

    private Email(string value)
    {
        Value = value;
    }

    public static Email Create(string email)
    {
        if (string.IsNullOrWhiteSpace(email) || !email.Contains('@'))
        {
            // Use a more robust validation library in a real app
            throw new ArgumentException("Invalid email format.", nameof(email));
        }
        return new Email(email);
    }
}

public record Money
{
    public decimal Amount { get; }
    public string Currency { get; }

    private Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }

    public static Money Create(decimal amount, string currency)
    {
        if (amount < 0)
        {
            throw new ArgumentException("Amount cannot be negative.", nameof(amount));
        }
        if (string.IsNullOrWhiteSpace(currency) || currency.Length != 3)
        {
            // A real app might check against a list of valid ISO codes
            throw new ArgumentException("Invalid currency code.", nameof(currency));
        }
        return new Money(amount, currency.ToUpper());
    }
}
```

Now, we can refactor our original classes to use these new, expressive types.

```csharp
public class Customer
{
    public Guid Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public Email Email { get; set; } // Much better!
}

public class Order
{
    public Guid Id { get; set; }
    public Guid CustomerId { get; set; }
    public Money TotalPrice { get; set; } // Clear and type-safe
}
```

## Benefits of the Refactored Approach

*   **Encapsulation:** All validation logic for a concept is in one placeâ€”its value object.
*   **Expressive and Type-Safe:** The code is self-documenting. It's impossible to accidentally create an `Order` with an invalid currency or a `Customer` with a malformed email.
*   **Maintainability:** If a business rule changes (e.g., new email validation rules), you only need to update it in one location.
*   **Reduced Bugs:** The compiler becomes your ally, preventing a whole class of bugs related to invalid data.

By replacing primitives with simple value objects, you make your domain model richer, your code safer, and your life as a developer much easier.