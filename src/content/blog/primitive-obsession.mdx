---
title: 'Tackling Primitive Obsession in C#'
date: "2024-01-20"
excerpt: 'Learn how to identify and eliminate the Primitive Obsession code smell in C# by creating expressive value objects that make your code more robust and maintainable.'
tags: ["C#", "Code Smell", "Primitive Obsession", "Value Objects"]
---

# Tackling Primitive Obsession in C#

**Primitive Obsession** is a common code smell where developers excessively use primitive data types (`string`, `int`, `decimal`) to represent meaningful domain concepts. Instead of creating specific, small classes for concepts like phone numbers, email addresses, or monetary values, we simply pass around basic strings and numbers.

While this approach might seem quick and convenient initially, it often leads to **fragile, less expressive, and harder-to-maintain code**.

---

## üö® The Problem: A Simple Example

Consider these `Customer` and `Order` classes in an e-commerce application. This implementation suffers from primitive obsession:

```csharp filename="Customer.cs"
public class Customer
{
    public Guid Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    // ‚ùå What makes this a valid email?
    public string Email { get; set; }
}

public class Order
{
    public Guid Id { get; set; }
    public Guid CustomerId { get; set; }
    // ‚ùå Is this price in USD, EUR, or something else?
    public decimal TotalPrice { get; set; }
    // ‚ùå How do we ensure this is a valid ISO currency code?
    public string Currency { get; set; }
}
```

---

## ‚ö†Ô∏è Why Is This a Problem?

This approach has several significant downsides:

### 1. **Implicit Knowledge**
The code doesn't explicitly state business rules. What constitutes a valid email? What format should the currency be? This knowledge is scattered across the codebase or exists only in developers' minds.

### 2. **No Centralized Validation**
Email validation logic gets repeated everywhere. When rules change, you must find and update every occurrence.

### 3. **Lack of Type Safety**
Any string can be passed as an email, any decimal as a price. The compiler can't prevent invalid data from entering your system.

### 4. **Reduced Readability**
Compare these method signatures:
```csharp
// ‚ùå Unclear relationship between parameters
ProcessPayment(decimal amount, string currency)

// ‚úÖ Clear, expressive, single concept
ProcessPayment(Money amount)
```

---

## ‚úÖ The Solution: Embracing Value Objects

The solution is to create small, immutable **Value Objects** that encapsulate the logic and validation for each domain concept. In modern C#, `record` types are perfect for this.

Let's create value objects for `Email` and `Money`:

### Email Value Object

```csharp filename="Email.cs"
public record Email
{
    public string Value { get; }

    private Email(string value)
    {
        Value = value;
    }

    public static Email Create(string email)
    {
        if (string.IsNullOrWhiteSpace(email) || !IsValidEmail(email))
        {
            throw new ArgumentException("Invalid email format.", nameof(email));
        }
        return new Email(email);
    }

    private static bool IsValidEmail(string email)
    {
        // Simplified validation - use a robust library in production
        return email.Contains('@') && email.Contains('.');
    }
}
```

### Money Value Object

```csharp filename="Money.cs"
public record Money
{
    public decimal Amount { get; }
    public string Currency { get; }

    private Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }

    public static Money Create(decimal amount, string currency)
    {
        if (amount < 0)
        {
            throw new ArgumentException("Amount cannot be negative.", nameof(amount));
        }
        if (!IsValidCurrency(currency))
        {
            throw new ArgumentException("Invalid currency code.", nameof(currency));
        }
        return new Money(amount, currency.ToUpper());
    }

    private static bool IsValidCurrency(string currency)
    {
        return !string.IsNullOrWhiteSpace(currency) && 
               currency.Length == 3 && 
               currency.All(char.IsLetter);
    }

    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException("Cannot add different currencies");
        
        return new Money(Amount + other.Amount, Currency);
    }
}
```

### Refactored Domain Classes

Now we can refactor our original classes to use these expressive types:

```csharp filename="RefactoredModels.cs"
public class Customer
{
    public Guid Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public Email Email { get; set; } // ‚úÖ Much better!
}

public class Order
{
    public Guid Id { get; set; }
    public Guid CustomerId { get; set; }
    public Money TotalPrice { get; set; } // ‚úÖ Clear and type-safe
}
```

---

## üéØ Benefits of the Refactored Approach

### ‚úÖ **Encapsulation**
All validation logic for a concept lives in one place‚Äîits value object.

### ‚úÖ **Expressive and Type-Safe**
The code is self-documenting. It's impossible to accidentally create invalid data.

### ‚úÖ **Maintainability**
Business rule changes require updates in only one location.

### ‚úÖ **Reduced Bugs**
The compiler prevents entire classes of bugs related to invalid data.

### ‚úÖ **Better Testing**
Value objects are easy to unit test in isolation.

---

## üí° Usage Example

```csharp filename="Program.cs"
// Creating instances
var email = Email.Create("user@example.com");
var price = Money.Create(99.99m, "USD");

// Using in business logic
var customer = new Customer 
{ 
    Email = email,
    FirstName = "John",
    LastName = "Doe"
};

var order = new Order 
{ 
    CustomerId = customer.Id,
    TotalPrice = price
};

// Type safety prevents errors
// var invalidEmail = Email.Create("not-an-email"); // ‚ùå Throws exception
// var invalidMoney = Money.Create(-10, "INVALID"); // ‚ùå Throws exception
```

---

## üöÄ Conclusion

By replacing primitive obsession with **value objects**, you create:
- **Richer domain models** that express business concepts clearly
- **Safer code** with compile-time validation
- **Easier maintenance** with centralized business rules
- **Better developer experience** with self-documenting APIs

Start small‚Äîidentify one primitive in your codebase that represents a domain concept and wrap it in a value object. You'll immediately see the benefits and want to apply this pattern throughout your application.